package com.cout970.glutilities.camera

import com.cout970.glutilities.util.Cache
import com.cout970.matrix.api.IMatrix4
import com.cout970.matrix.extensions.*
import com.cout970.vector.api.IQuaternion
import com.cout970.vector.api.IVector2
import com.cout970.vector.api.IVector3
import com.cout970.vector.extensions.Quaternion
import com.cout970.vector.extensions.toDegrees
import com.cout970.vector.extensions.unaryMinus
import com.cout970.vector.extensions.vec3Of


/**
 * Created by cout970 on 30/07/2016.
 */
/**
 * Implementation of basic camera for a 3D space
 * @see OrthoCamera
 * @see PerspectiveCamera
 */
//TODO
abstract class AbstractCamera : ICamera {
    val cache = Cache { getProjection() * getView() }

    //The position of the camera
    var position: IVector3 = vec3Of(0)
        set(i){ cache.dirty = true }
    //Quaternion of the camera rotation
    var rotations: IQuaternion = Quaternion.IDENTITY
        set(i){ cache.dirty = true }
    //the scale of the 3D space
    var scale: IVector3 = vec3Of(1.0)
        set(i){ cache.dirty = true }

    override fun getViewMatrix() = cache.value

    /**
     * Creates a view matrix
     */
    open fun getView() = mutableMat4Of().apply { translate(-position); rotate(rotations); scale(scale) }

    /**
     * Creates a projection matrix
     */
    abstract fun getProjection(): IMatrix4

    /**
     * This function allow to adjust the aspect ratio of the projection matrix generated by this camera
     */
    override fun updateViewport(size: IVector2) {
    }

    override fun toString(): String {
        return "Camera(position=$position, rotations=${rotations.toDegrees()}, scale=$scale)"
    }
}